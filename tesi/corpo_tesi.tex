% 12pt: grandezza carattere
% a4paper: formato a4
% openright: apre i capitoli a destra
% twoside: serve per fare un documento fronteretro
% report: stile tesi (oppure book)
\documentclass[12pt,a4paper,openright,twoside]{report}

\usepackage[italian]{babel} 	% libreria per scrivere in italiano
\usepackage[utf8]{inputenc}   % libreria per accettare i caratteri digitati da tastiera come 'è' o 'à'
\usepackage{fancyhdr}   		% libreria per impostare il documento
\usepackage{indentfirst}    	% libreria per avere l'indentazione all'inizio dei capitoli
%\usepackage{showkeys}  		% libreria per mostrare le etichette
\usepackage{graphicx}   		% libreria per inserire grafici
\usepackage{newlfont}   		% libreria per utilizzare font particolari ad esempio \textsc{}
% librerie matematiche
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsthm}

\oddsidemargin=30pt \evensidemargin=20pt	% impostano i margini
%\hyphenation{sil-la-ba-zio-ne pa-ren-te-si}	% serve per la sillabazione: tra parentesi vanno inserite come nell'esempio le parole che latex non riesce a tagliare nel modo giusto andando a capo

% comandi per l'impostazione della pagina, vedi il manuale della libreria fancyhdr per ulteriori delucidazioni
\pagestyle{fancy}\addtolength{\headwidth}{20pt}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\cfoot{}

\linespread{1.3}	% comando per impostare l'interlinea



\begin{document}


\pagenumbering{arabic}		% mette i numeri arabi


\tableofcontents	% crea l'indice

% imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INDICE}}

\clearpage{\pagestyle{empty}\cleardoublepage}	% non numera l'ultima pagina sinistra


%\listoffigures		% crea l'elenco delle figure

%\clearpage{\pagestyle{empty}\cleardoublepage}		% non numera l'ultima pagina sinistra


%\listoftables		% crea l'elenco delle tabelle

%\clearpage{\pagestyle{empty}\cleardoublepage}		% non numera l'ultima pagina sinistra


\chapter{Introduzione}		% crea l'introduzione

% imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries
INTRODUZIONE}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INTRODUZIONE}}

Il lavoro da me svolto consiste nell'implementazione dell'algoritmo di type inference di Haskell in ELPI.\\

\section{Stato dell'arte}

\subsection{Premesse}
Iniziamo questa trattazione ponendo alcune basi. Esse faciliteranno la comprensione degli argomenti successivi.
\begin{description}
 \item[Haskell] Haskell è un linguaggio di programmazione che adotta il paradigma di programmazione funzionale. Al suo interno è presente il lambda calcolo e il meccanismo delle type class; è presente inoltre una parte più ampia che corrisponde alle librerie.
 \item[Type inference] La type inference è il rilevamento automatico del tipo di dato di un'espressione in un linguaggio di programmazione. La capacità di dedurre i tipi automaticamente semplifica molte attività di programmazione, lasciando il programmatore libero di omettere le annotazioni sui tipi pur consentendo il type check.
 \item[ELPI] ELPI è un linguaggio di programmazione logico. Esso è un'estensione con vincoli del linguaggio $\lambda$Prolog, il quale a sua volta è un'estensione di Prolog a una logica di ordine superiore.
 \item[Prolog] Prolog è un linguaggio di programmazione che adotta il paradigma di programmazione logica. Si basa sul calcolo dei predicati (logica del prim'ordine); la sintassi è composta da formule dette clausole. L'esecuzione di un programma Prolog è comparabile alla dimostrazione di un teorema mediante la regola di inferenza detta risoluzione (essa permette di passare da un numero finito di proposizioni assunte come premesse a una proposizione che funge da conclusione). I concetti fondamentali di questo linguaggio sono l'unificazione, la ricorsione in coda e il backtracking.
 \item[Clausola] La clausola è una disgiunzione di letterali del prim'ordine. Essa è della forma:
 \begin{equation}
  H :- A_1,\ldots,A_n.
 \end{equation}
 La semantica è quella di una implicazione rovesciata: $H \leftarrow A_1 \wedge \ldots \wedge A_n$. Se n = 0 il simbolo $:-$ è omesso, ma non il punto finale. Un programma logico è un insieme di clausole. Una query è una sequenza di atomi $A_1,\ldots,A_n$.
 \item[$\lambda$Prolog] $\lambda$Prolog è, come già detto, un'estensione di Prolog. Le caratteristiche principali in aggiunta, rispetto a Prolog, sono il polimorfismo, la programmazione di ordine superiore e il lambda calcolo tipato.
\end{description}

\subsection{Limiti di $\lambda$Prolog}
Non essendo $\lambda$Prolog un linguaggio di programmazione con vincoli risulta impossibile implementare la type inference mediante esso. I limiti dell'utilizzo di tale linguaggio si riscontrano in particolare nel tentativo di codificare il tipaggio per i costrutti del let-in e della type class.\\
L'unica strategia percorribile sarebbe quella di codificare interamente il sistema punto per punto. In tal caso però si creerebbe un sistema estremamente rigido, il che rende tale strategia impraticabile. Ad esempio, infatti, si potrebbe codificare tutto nelle stringhe e svolgere ogni operazione attraverso di esse; a quel punto ogni cosa sarebbe implementabile, il sistema in questione sarebbe infatti Turing completo. Il problema però è il fatto che in tal caso si dovrebbero abbandonare tutte le features del linguaggio $\lambda$Prolog; infatti la rigidezza del sistema creato non consentirebbe l'utilizzo delle stesse, poiché si risulterebbe vincolati alla nuova struttura.\\
Si è reso dunque necessario l'utilizzo di ELPI, la cui maggiore espressività (non nel senso della Turing completezza) permette di svolgere operazioni impossibili da codificare in $\lambda$Prolog. Prendiamo come esempio i due casi indicati precedentemente:
\begin{itemize}
 \item Per codificare il tipaggio del let-in è necessario l'utilizzo del meccanismo mode di ELPI. Infatti esso offre un maggior controllo sugli elementi del codice poiché permette di accorgersi se essi sono delle variabili non istanziate, così da poterle gestire in modo appropriato.
 \item Per codificare il tipaggio della type class è necessario l'utilizzo dei vincoli. Infatti questi possono sussistere anche non totalmente istanziati e quindi permettono, ad esempio, di fissare l'obbligo di appartenenza di una variabile di tipo non istanziata ad un'istanza di type class.
\end{itemize}
Entrambi i requisiti sono caratteristiche presenti in ELPI ma non in $\lambda$Prolog. Risulta dunque evidente la necessità di utilizzare ELPI come linguaggio di programmazione per poter raggiungere lo scopo prefissato.

\section{ELPI}

\subsection{Introduzione al linguaggio}
ELPI, così come $\lambda$Prolog, è un linguaggio logico di ordine superiore (HOLP language - Higher Order Logic Programming language). La loro differenza consiste nel fatto che ELPI possiede in aggiunta il sistema dei vincoli: infatti esso è un Higher Order constraint Logic Programming language.\\
Spieghiamo alcuni concetti:
\begin{description}
 \item[HOLP] La programmazione di ordine superiore è uno stile di programmazione che usa elementi del linguaggio (ad esempio funzioni, oggetti, \ldots) come valori. Ad esempio le funzioni possono essere passate come argomenti di altre funzioni oppure possono essere il valore di ritorno di altre funzioni. È solitamente istanziato con il modello di computazione del lambda calcolo, il quale utilizza funzioni di ordine superiore.
 \item[CLP] La programmazione logica con vincoli (Constraint Logic Programming), estensione della programmazione logica, è un paradigma di programmazione dove le relazioni fra variabili possono essere dichiarate in forma di vincoli. Un vincolo è una formula della logica del prim'ordine (solitamente una congiunzione di formule atomiche) che usa solo predicati di significato predefinito.
\end{description}

\subsection{Sistema di propagazione dei vincoli}
Spieghiamo ora il sistema dei vincoli, nel caso specifico di ELPI.\\
Generalmente l'approccio con ELPI è il seguente:
\begin{enumerate}
 \item Si dichiara il \verb"mode";
 \item Lo si trasforma in un vincolo;
 \item Se si ha dei teoremi li si aggiunge, essi sono utili per evitare un accumulo non necessario di vincoli.
\end{enumerate}
\begin{description}
 \item[Primo punto] Si raggiunge definendo il \verb"mode" di un costrutto.\\
 Struttura:
 \begin{center}
 \verb"mode ("\textit{costrutto  serie di}\verb" i  "\textit{serie di}\verb"o)."
 \end{center}
 \item[Secondo punto] Si risolve dichiarando che un predicato contenente quel costrutto, il quale presenta in input una variabile non istanziata, può essere soddisfatto aggiungendo un vincolo contentente quel costrutto al cui interno sarà presente la variabile non istanziata; viene inoltre fissata la lista di variabili non istanziate la quale, una volta soddisfatta (cioè una volta istanziate le variabili in essa contenute), dà il via alla processazione del vincolo. Infatti un vincolo viene ricordato senza essere processato: sarà processato nel momento in cui le variabili saranno istanziate.\\
 Struttura:
 \begin{center}
 \textit{costrutto}\verb" (uvar _ as "\textit{variabile non istanziata}\verb") :-"\\
 \verb"!, declare_constraint ("\textit{vincolo}\verb") ["\textit{variabile non istanziata}\verb"]."
 \end{center}
 \item[Terzo punto] Il terzo punto si ottiene definendo uno o più blocchi \verb"constraint". Al suo interno saranno presenti una o più \verb"rule", regole di riscrittura dei vincoli. Esse sono della forma:
 \begin{center}
  \verb"rule "\textit{tengo}\verb" \ "\textit{tolgo}\verb" <=> "\textit{condizione}\verb" | "\textit{aggiungo}\verb"."
 \end{center}
 Oppure può trovarsi in una delle forme ristrette:
 \begin{center}
  \verb"rule \ "\textit{tolgo}\verb" <=> "\textit{condizione}\verb" | "\textit{aggiungo}\verb"."\\
  \verb"rule "\textit{tengo}\verb" \ "\textit{tolgo}\verb" <=> "\textit{aggiungo}\verb"."\\
  \verb"rule \ "\textit{tolgo}\verb" <=> "\textit{aggiungo}\verb"."\\
 \end{center}\\
 Struttura:
 \begin{center}
  \verb"constraint "\textit{costrutto}\verb" {"\textit{regole}\verb"}"
 \end{center}
\end{description}

Il sistema di propagazione dei vincoli consiste nella riscrittura di insiemi di vincoli in altri insiemi di vincoli.

\subsubsection{Esempi}
Per comprendere meglio il concetto presento ora due pezzi di codice, parte del mio lavoro.\\
\begin{itemize}
 \item Implementazione di \verb"of", il costrutto utilizzato per codificare il tipaggio di un termine.
  \begin{verbatim}
   type of term -> tipo -> prop.
   mode (of i o).
   of (uvar _ as X) T :- !, declare_constraint (of X T) [X].
  \end{verbatim}
 \item Implementazione di \verb"eqp_tipo", il costrutto utilizzato per la codifica dell'uguaglianza di due tipi.
  \begin{verbatim}
   type eqp_tipo tipo -> tipo -> prop.
   constraint eqp_tipo {
    rule \ (eqp_tipo A A) <=> true.
    rule \ (eqp_tipo A B) <=> false.
   }
  \end{verbatim}
\end{itemize}




























\section{Haskell}
% ...
\subsection{BNF utilizzata}
% ...
\subsection{Type class}
% ...
\subsection{Let-in}
% ...

\section{Finalità}
% ~ scopo del mio lavoro
% ...

\clearpage{\pagestyle{empty}\cleardoublepage}	% non numera l'ultima pagina sinistra


\chapter{Implementazione}		% crea il capitolo

\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}	% imposta l'intestazione di pagina

% ...

\section{STLC}
% ...

\section{Funzioni ricorsive, match}
% ...

\section{Type class, instanza, schema}
% ...

\section{Let-in}
% ...

\clearpage{\pagestyle{empty}\cleardoublepage}		% non numera l'ultima pagina sinistra


\chapter{Conclusioni}		% per fare le conclusioni

% imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries
CONCLUSIONI}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
CONCLUSIONI}}

% ...

\section{Riassumendo}
% ...

\section{La mia esperienza con ELPI}
% ...

\section{Il mio lavoro}
% ...

\section{Sviluppi futuri}
% ...
\subsection{Parser}
% ...
\subsection{Testing}
% ...
\subsection{Estensioni}
% ...


%\begin{thebibliography}{90}		% crea l'ambiente bibliografia

%\rhead[\fancyplain{}{\bfseries \leftmark}]{\fancyplain{}{\bfseries
%\thepage}}

%\addcontentsline{toc}{chapter}{Bibliografia}	% aggiunge la voce Bibliografia nell'indice
%%\addcontentsline{toc}{chapter}{\numberline{}{Bibliografia}}	% provare anche questo comando

%\bibitem{K1} Primo oggetto bibliografia.
%\bibitem{K2} Secondo oggetto bibliografia.
% ...

%\end{thebibliography}

\clearpage{\pagestyle{empty}\cleardoublepage}	% non numera l'ultima pagina sinistra


\chapter*{Ringraziamenti}

\thispagestyle{empty}

% ...


\end{document}
