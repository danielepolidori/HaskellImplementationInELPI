% 12pt: grandezza carattere
% a4paper: formato a4
% openright: apre i capitoli a destra
% twoside: serve per fare un documento fronteretro
% report: stile tesi (oppure book)
\documentclass[12pt,a4paper,openright,twoside]{report}

\usepackage[italian]{babel} 	% libreria per scrivere in italiano
\usepackage[utf8]{inputenc}   % libreria per accettare i caratteri digitati da tastiera come 'è' o 'à'
\usepackage{fancyhdr}   		% libreria per impostare il documento
\usepackage{indentfirst}    	% libreria per avere l'indentazione all'inizio dei capitoli
%\usepackage{showkeys}  		% libreria per mostrare le etichette
\usepackage{graphicx}   		% libreria per inserire grafici
\usepackage{newlfont}   		% libreria per utilizzare font particolari ad esempio \textsc{}
% librerie matematiche
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsthm}

\usepackage{syntax}

\oddsidemargin=30pt \evensidemargin=20pt	% impostano i margini
%\hyphenation{sil-la-ba-zio-ne pa-ren-te-si}	% serve per la sillabazione: tra parentesi vanno inserite come nell'esempio le parole che latex non riesce a tagliare nel modo giusto andando a capo

% comandi per l'impostazione della pagina, vedi il manuale della libreria fancyhdr per ulteriori delucidazioni
\pagestyle{fancy}\addtolength{\headwidth}{20pt}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\cfoot{}

\linespread{1.3}	% comando per impostare l'interlinea



\begin{document}


\pagenumbering{arabic}		% mette i numeri arabi


\tableofcontents	% crea l'indice

% imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INDICE}}

\clearpage{\pagestyle{empty}\cleardoublepage}	% non numera l'ultima pagina sinistra


%\listoffigures		% crea l'elenco delle figure

%\clearpage{\pagestyle{empty}\cleardoublepage}		% non numera l'ultima pagina sinistra


%\listoftables		% crea l'elenco delle tabelle

%\clearpage{\pagestyle{empty}\cleardoublepage}		% non numera l'ultima pagina sinistra


\chapter{Introduzione}		% crea l'introduzione

% imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries
INTRODUZIONE}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INTRODUZIONE}}

Il lavoro da me svolto consiste nell'implementazione dell'algoritmo di type inference di Haskell in ELPI.\\

\section{Stato dell'arte}

\subsection{Premesse}
Iniziamo questa trattazione ponendo alcune basi. Esse faciliteranno la comprensione degli argomenti successivi.
\begin{description}
 \item[Haskell] Haskell è un linguaggio di programmazione che adotta il paradigma di programmazione funzionale. Al suo interno è presente il lambda calcolo e il meccanismo delle type class; è presente inoltre una parte più ampia che corrisponde alle librerie.
 \item[Type inference] La type inference è il rilevamento automatico del tipo di dato di un'espressione in un linguaggio di programmazione. La capacità di dedurre i tipi automaticamente semplifica molte attività di programmazione, lasciando il programmatore libero di omettere le annotazioni sui tipi pur consentendo il type check.
 \item[ELPI] ELPI è un linguaggio di programmazione logico. Esso è un'estensione con vincoli del linguaggio $\lambda$Prolog, il quale a sua volta è un'estensione di Prolog a una logica di ordine superiore.
 \item[Prolog] Prolog è un linguaggio di programmazione che adotta il paradigma di programmazione logica. Si basa sul calcolo dei predicati (logica del prim'ordine); la sintassi è composta da formule dette clausole. L'esecuzione di un programma Prolog è comparabile alla dimostrazione di un teorema mediante la regola di inferenza detta risoluzione (essa permette di passare da un numero finito di proposizioni assunte come premesse a una proposizione che funge da conclusione). I concetti fondamentali di questo linguaggio sono l'unificazione, la ricorsione in coda e il backtracking.
 \item[Clausola] La clausola è una disgiunzione di letterali del prim'ordine. Essa è della forma:
 \begin{equation}
  H :- A_1,\ldots,A_n.
 \end{equation}
 La semantica è quella di una implicazione rovesciata: $H \Leftarrow A_1 \wedge \ldots \wedge A_n$. Se n = 0 il simbolo $:-$ è omesso, ma non il punto finale. Un programma logico è un insieme di clausole. Una query è una sequenza di atomi $A_1,\ldots,A_n$.
 \item[$\lambda$Prolog] $\lambda$Prolog è, come già detto, un'estensione di Prolog. Le caratteristiche principali in aggiunta, rispetto a Prolog, sono il polimorfismo, la programmazione di ordine superiore e il lambda calcolo tipato.
\end{description}

\subsection{Limiti di $\lambda$Prolog}
Non essendo $\lambda$Prolog un linguaggio di programmazione con vincoli risulta impossibile implementare la type inference mediante esso. I limiti dell'utilizzo di tale linguaggio si riscontrano in particolare nel tentativo di codificare il tipaggio per i costrutti del let-in e della type class.\\
L'unica strategia percorribile sarebbe quella di codificare interamente il sistema punto per punto. In tal caso però si creerebbe un sistema estremamente rigido, il che rende tale strategia impraticabile. Ad esempio, infatti, si potrebbe codificare tutto nelle stringhe e svolgere ogni operazione attraverso di esse; a quel punto ogni cosa sarebbe implementabile, il sistema in questione sarebbe infatti Turing completo. Il problema però è il fatto che in tal caso si dovrebbero abbandonare tutte le features del linguaggio $\lambda$Prolog; infatti la rigidezza del sistema creato non consentirebbe l'utilizzo delle stesse, poiché si risulterebbe vincolati alla nuova struttura.\\
Si è reso dunque necessario l'utilizzo di ELPI, la cui maggiore espressività (non nel senso della Turing completezza) permette di svolgere operazioni impossibili da codificare in $\lambda$Prolog. Prendiamo come esempio i due casi indicati precedentemente:
\begin{itemize}
 \item Per codificare il tipaggio del let-in è necessario l'utilizzo del meccanismo mode di ELPI. Infatti esso offre un maggior controllo sugli elementi del codice poiché permette di accorgersi se essi sono delle variabili non istanziate, così da poterle gestire in modo appropriato.
 \item Per codificare il tipaggio della type class è necessario l'utilizzo dei vincoli. Infatti questi possono sussistere anche non totalmente istanziati e quindi permettono, ad esempio, di fissare l'obbligo di appartenenza di una variabile di tipo non istanziata ad un'istanza di type class.
\end{itemize}
Entrambi i requisiti sono caratteristiche presenti in ELPI ma non in $\lambda$Prolog. Risulta dunque evidente la necessità di utilizzare ELPI come linguaggio di programmazione per poter raggiungere lo scopo prefissato.

\section{ELPI}

\subsection{Introduzione al linguaggio}
ELPI, così come $\lambda$Prolog, è un linguaggio logico di ordine superiore (HOLP language - Higher Order Logic Programming language). La loro differenza consiste nel fatto che ELPI possiede in aggiunta il sistema dei vincoli: infatti esso è un Higher Order constraint Logic Programming language.\\
Spieghiamo alcuni concetti:
\begin{description}
 \item[HOLP] La programmazione di ordine superiore è uno stile di programmazione che usa elementi del linguaggio (ad esempio funzioni, oggetti, \ldots) come valori. Ad esempio le funzioni possono essere passate come argomenti di altre funzioni oppure possono essere il valore di ritorno di altre funzioni. È solitamente istanziato con il modello di computazione del lambda calcolo, il quale utilizza funzioni di ordine superiore.
 \item[CLP] La programmazione logica con vincoli (Constraint Logic Programming), estensione della programmazione logica, è un paradigma di programmazione dove le relazioni fra variabili possono essere dichiarate in forma di vincoli. Un vincolo è una formula della logica del prim'ordine (solitamente una congiunzione di formule atomiche) che usa solo predicati di significato predefinito.
\end{description}

\subsection{Sistema di propagazione dei vincoli}
Spieghiamo ora il sistema dei vincoli, nel caso specifico di ELPI.\\
Generalmente l'approccio con ELPI è il seguente:
\begin{enumerate}
 \item Si dichiara il \verb"mode";
 \item Lo si trasforma in un vincolo;
 \item Se si ha dei teoremi li si aggiunge, essi sono utili per evitare un accumulo non necessario di vincoli.
\end{enumerate}
\begin{description}
 \item[Primo punto] Si raggiunge definendo il \verb"mode" di un costrutto. Saranno presenti un numero di \verb"i" e di \verb"o" pari, rispettivamente, alla quantità di elementi in input e in output al costrutto.\\
 Struttura:
 \begin{center}
 \verb"mode ("\textit{costrutto}\verb" i o)."
 \end{center}
 \item[Secondo punto] Si risolve dichiarando che un predicato contenente quel costrutto, il quale presenta in input una o più variabili non istanziate, può essere soddisfatto aggiungendo al programma un vincolo contentente quel costrutto al cui interno saranno presenti le variabili non istanziate; viene inoltre fissata una lista delle variabili non istanziate la quale, una volta soddisfatta (cioè una volta istanziate le variabili in essa contenute), dà il via alla processazione del vincolo. Infatti un vincolo viene ricordato senza essere processato: sarà processato soltanto nel momento in cui le variabili ad esso associate saranno istanziate.\\
 Struttura:
 \begin{center}
 \textit{costrutto}\verb" (uvar _ as "\textit{variabile non istanziata}\verb") :-"\\
 \verb"!, declare_constraint ("\textit{vincolo}\verb") ["\textit{variabili non istanziate}\verb"]."
 \end{center}
 \item[Terzo punto] Si ottiene definendo uno o più blocchi \verb"constraint". Al suo interno saranno presenti una o più \verb"rule", regole di riscrittura dei vincoli. Esse sono della forma:
 \begin{center}
  \verb"rule "\textit{tengo}\verb" \ "\textit{tolgo}\verb" <=> "\textit{condizione}\verb" | "\textit{aggiungo}\verb"."
 \end{center}
 Oppure possono trovarsi in una delle forme ristrette:
 \begin{center}
  \verb"rule \ "\textit{tolgo}\verb" <=> "\textit{condizione}\verb" | "\textit{aggiungo}\verb"."\\
  \verb"rule "\textit{tengo}\verb" \ "\textit{tolgo}\verb" <=> "\textit{aggiungo}\verb"."\\
  \verb"rule \ "\textit{tolgo}\verb" <=> "\textit{aggiungo}\verb"."\\
 \end{center}
 Struttura:
 \begin{center}
  \verb"constraint "\textit{costrutto}\verb" {"\textit{regole}\verb"}"
 \end{center}
\end{description}

Il sistema di propagazione dei vincoli consiste nella riscrittura di insiemi di vincoli in altri insiemi di vincoli.

\subsubsection{Esempi}
Per comprendere meglio il concetto presento ora due frammenti di codice, estrapolati dal mio lavoro.\\
\begin{itemize}
 \item Implementazione di \verb"of", il costrutto utilizzato per codificare il tipaggio di un termine.
  \begin{verbatim}
   type of term -> tipo -> prop.
   mode (of i o).
   of (uvar _ as X) T :- !, declare_constraint (of X T) [X].
  \end{verbatim}
 \item Implementazione di \verb"eqp_tipo", il costrutto utilizzato per la codifica dell'uguaglianza di due tipi.
  \begin{verbatim}
   type eqp_tipo tipo -> tipo -> prop.
   constraint eqp_tipo {
    rule \ (eqp_tipo A A) <=> true.
    rule \ (eqp_tipo A B) <=> false.
   }
  \end{verbatim}
\end{itemize}

\section{Haskell}

Il mio lavoro comprende l'implementazione di una parte di Haskell, non di tutto il linguaggio. Presento ora gli argomenti da me trattati.

\subsection{BNF}
\begin{grammar}
 \let\syntleft\relax    % do not display '<' associated with variable, for example <A>
 \let\syntright\relax   % do not display '>' associated with variable, for example <A>
 %<T> ::= A | T $\rightarrow$ T
 %<t> ::= x | t t | $\lambda$x.t | case t of a | let d in t | if t then t else t
 <T> ::= t | T $\rightarrow$ T
 
 <E> ::= e | E E | $\lambda$e.E | case E of $a_1 \ldots a_n$ | let $d_1 \ldots d_n$ in E | if E then E else E
\end{grammar}

%\subsection{Case}
% ...

\subsection{Let-in}
Il costrutto del let-in è costituito da:
\begin{itemize}
 \item Una lista di dichiarazioni che associano, ciascuna, un nome ad un termine;
 \item Un corpo che è un'espressione che contiene i termini definiti nelle dichiarazioni.
\end{itemize}

\subsection{Type class}
Un altro elemento da cui Haskell è costituito è il meccanismo delle type class. Una type class è un costrutto di un sistema di tipi che supporta il polimorfismo parametrico. Esso è ottenuto aggiungendo vincoli alle variabili di tipo. Questi tipicamente coinvolgono una type class e una variabile di tipo e indicano che la variabile può essere istanziata solamente con un tipo che soddisfa le operazioni associate alla type class. Una type class può quindi essere considerata come una sorta di insieme vincolato di tipi.\\
Paragonando questo sistema con il paradigma di programmazione orientato agli oggetti potremmo dire che, rispettivamente, le type class stanno ai tipi come le classi stanno agli oggetti. Il meccanismo delle type class, infatti, nasce come risposta ad alcuni problemi dovuti all'utilizzo del meccanismo dell'ereditarietà nella programmazione orientata agli oggetti.

\clearpage{\pagestyle{empty}\cleardoublepage}	% non numera l'ultima pagina sinistra


\chapter{Implementazione}		% crea il capitolo

\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}	% imposta l'intestazione di pagina

% ...

\section{STLC}
% ...

\section{Funzioni ricorsive, match}
% ...

\section{Type class, istanza, schema}
% ...

\section{Let-in}
% ...

\clearpage{\pagestyle{empty}\cleardoublepage}		% non numera l'ultima pagina sinistra


\chapter{Conclusioni}		% per fare le conclusioni

% imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries
CONCLUSIONI}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
CONCLUSIONI}}

% ...

\section{Riassumendo}
% ...

\section{Finalità}
% ~ scopo del mio lavoro
% ...

\section{La mia esperienza con ELPI}
% ...

\section{Il mio lavoro}
% ...

\section{Sviluppi futuri}
% ...
\subsection{Parser}
% ...
\subsection{Testing}
% ...
\subsection{Estensioni}
% ...


%\begin{thebibliography}{90}		% crea l'ambiente bibliografia

%\rhead[\fancyplain{}{\bfseries \leftmark}]{\fancyplain{}{\bfseries
%\thepage}}

%\addcontentsline{toc}{chapter}{Bibliografia}	% aggiunge la voce Bibliografia nell'indice
%%\addcontentsline{toc}{chapter}{\numberline{}{Bibliografia}}	% provare anche questo comando

%\bibitem{K1} Primo oggetto bibliografia.
%\bibitem{K2} Secondo oggetto bibliografia.
% ...

%\end{thebibliography}

\clearpage{\pagestyle{empty}\cleardoublepage}	% non numera l'ultima pagina sinistra


\chapter*{Ringraziamenti}

\thispagestyle{empty}

% ...


\end{document}
