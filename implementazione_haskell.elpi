%%% Simply typed lambda calculus

kind tipo type.
kind term type.

type app term -> term -> term.
type lam (term -> term) -> term.

type arr tipo -> tipo -> tipo.

type of term -> tipo -> prop.

mode (of i o).
of (uvar _ as X) T :- !, declare_constraint (of X T) [X].
of (app X Y) B :- of X (arr A B), of Y A.
of (lam F) (arr A B) :- pi x \ of x A => of (F x) B.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% (31/10/2019)
% TODO 1: haskell senza type classes
%  - implementare tutti i costrutti Haskell
%    usabili per definire funzioni
%    es. pattern matching (case), e let-in
%  - definire un programma Haskell come una lista
%    di funzioni ovvero coppie nome-corpo
%  - aggiungere il forall ai tipi
%    es:  forall T \ list T -> list T -> list T
%    ovvero: un tipo e' dato da una lista di
%    forall (imbricati) terminati da un tipo
%    fatto da sole arr
%    es. forall K \ forall V \ arr (K (arr (hash K V) V))
%    controesempio:  arr T (forall K \ K)
%  - implementare il predicato of per i nuovi costrutti
%  - la regola of per le funzioni deve inserire i
%    forall per ogni meta-variabile rimasta tale nel
%    corpo (ELPI only)


%%% Forall aggiunto ai tipi

% Si possono avere due tipi (quello fatto di forall+arr e quello fatto di sole arr)
%
%   es_forall+arr:      for_all T1 \ for_all T2 \ base (arr T1 T2)
%   es_arr:             arr T1 T2

kind schema type.

type for_all (tipo -> schema) -> schema.
type base tipo -> schema.

% es.:   for_all X \ for_all Y \ base (arr X Y).


%%% Funzioni come coppie nome-corpo

% Tre casi d'uso:
%
%   - Dichiarazione      es: fun_decl print (for_all T \ base (arr T int))
%   - Implementazione    es: fun_impl print (lam x \ x)
%   - Uso                es: app (fun print) 4

kind nome_fun type.
kind declaration type.
type fun_decl nome_fun -> schema -> declaration.
%             nome funzione -> tipo funzione -> _ .
% es:   fun_decl foo (for_all T \ base (arr T T))
type assume declaration -> prop.

kind implementation type.
type fun_impl nome_fun -> term -> implementation.
%             nome funzione -> corpo funzione -> _ .
% es:   fun_impl foo1 (lam x \ lam y \ x + y)
%       fun_impl foo2 (case_of x [branch (nat 0) (num 0), branch (succ N) (nat_to_num (succ (succ N)))])
%       fun_impl foo3 (let_in [coppia_decl id (lam A \ A)] (id 4))

type fun nome_fun -> term.

% es:   app (fun print) 4
%       =
%       print 4

% ~ Va aggiunto anche 'fun_impl N C' a destra?
of (fun N) T :- assume (fun_decl N S), instantiate S T.											% Caso 1: funzione a sé stante
of (fun N) T :- typeclass N1 T1 L, is_fun_in_decls L N S, instantiate S T, istanza N1 T1 _.		% Caso 2: funzione che è parte di una typeclass
% ~ È giusto che istanza e typeclass abbiano lo stesso tipo T1? Non dovrebbe essere che la typeclass ha un tipo generico e l'istanza un tipo concreto?

% Controlla che la funzione con quel nome e con quello schema sia presente nella lista di dichiarazioni
type is_fun_in_decls list declaration -> nome_fun -> schema -> prop.
is_fun_in_decls [fun_decl N2_ S2_ | TL] N1 S1 :- is_fun_in_decls TL N1 S1.
is_fun_in_decls [fun_decl N S | TL_] N S.

% Per passare da un tipo forall+arr al rispettivo tipo di sole arr
type instantiate schema -> tipo -> prop.
instantiate (base T) T.
instantiate (for_all S) O :- instantiate (S T_) O.

% es.
%  Term =
%   let id = lam A \ A in     % il termine A \ A ha tipo X -> X
%                             % id viene dichiarato con schema for_all X \ X -> X
%    id 4                     % ha tipo int
%  tutto Term ha tipo int


%%% Typeclasses

kind nome_classe type.
type typeclass nome_classe -> tipo -> list declaration -> prop.
type istanza nome_classe -> tipo -> list implementation -> prop.

mode (istanza i i o).
istanza N (uvar _ as X) L :- !, declare_constraint (istanza N X L) [X].


%%% ADT (Algebraic Data Types)

% Li abbiamo introdotti perché necessari per il costrutto case

% Esempio in pseudocodice:
%
% type nat = O | S of nat
% type List A = [] | :: of A * (List A)
% type Tree K V = Leaf of K * V | Node of (Tree K V) * V * (Tree K V)
% type option A = None | Some of A

type nat int -> term.
type succ term -> term.
% es:   nat 0
% es:   succ (succ (succ (nat 0)))
type natural tipo.
of (nat _) natural.
of (succ _) natural.

type lista_vuota term.
type lista list term -> term.
% es:   lista_vuota
% es:   lista [H|TL]
type lista tipo.
of lista_vuota lista.
of (lista _) lista.

type leaf int -> term -> term.	% ~ È giusto che V sia considerato di tipo 'term'?
type node term -> int -> term -> term.
% es:   leaf 3 x
% es:   node (leaf 4 x) 9 (node (leaf 11 y) 13 (leaf 15 z))
type tree tipo.
of (leaf _ _) tree.
of (node _ _ _) tree.

type none term.
type some term -> term.	% ~ È giusto che A sia considerato di tipo 'term'?
% es:   none
% es:   some x
type option tipo.
of none option.
of (some _) option.


%%% Costrutto case

% Esempio in pseudocodice:
%
%  let f x =
%   match x of
%      O => O
%    | S y => y + 2
%
%  let sum x =
%   match x of
%      [] => O
%    | y::L => y + sum L 
%
%  let search K1 T =
%   match T with
%      Leaf(K2,V) => if K1 == K2 then Some V else None
%    | Node(T1,K2,T2) => if K1 <= K2 then search K1 T1 else search K1 T2

kind pair type.
type case_of term -> list pair -> term.
type branch term -> term -> pair.
% es:   case_of x [branch (nat 0) (num 0), branch (succ N) (nat_to_num (succ (succ N)))]
% es:   fun_impl sum (x \ case_of x [branch lista_vuota (num 0), branch (lista [H|TL]) (num (H + (sum TL)))])
% es:   fun_impl search (k1 \ t \ case_of t [branch (leaf K2 V) (if (k1 == K2) then (some V) else none), branch (node T1 K2 T2) (if (k1 <= K2) then (search k1 T1) else (search k1 T2))])

% Il case intero ha come tipo il tipo dell'output dei singoli rami
of (case_of X L) T1 :- of X T2, check_list_case L T1 T2.

% ~ È sbagliata: non devono avere tutti lo stesso tipo, ma ogni ramo ha il suo tipo
% Controlla che, per ogni coppia, gli elementi di input abbiano tutti lo stesso tipo dell'input del case e gli elementi di output abbiano tutti un certo tipo
type check_list_case list pair -> tipo -> tipo -> prop.
check_list_case [branch A B | TL] T1 T2 :- of A T2, of B T1, check_list_case TL T1 T2.
check_list_case [] _T1 _T2.		% Caso base


%%% Costrutto let-in

% es:
%       let
%           id = lam A \ A
%       in
%           id 4

% es:
%       let
%           even = lam x \ match x with O => true | S n => odd n
%           odd  = lam x \ match x with O => false | S n => even n
%       in
%           even 3
%
%       Nella mia sintassi:
%        let_in [coppia_decl even (lam x \ case_of x [branch (nat 0) true, branch (succ N) (odd N)]), coppia_decl odd (lam x \ case_of x [branch (nat 0) false, branch (succ N) (even N)])] (even 3)
%
% ~ DA FARE: me lo ha scritto il prof al ricevimento del 17/12/2019
% a) prima passata: associ a even Teven e a odd Todd (variabili fresche)
% b) chiami  of (corpo_di_even) Teven e poi of (corpo_di_odd) Todd
% c) [TODO] trasformare i tipi Teven e Todd in schema tramite constraints
% d) tipi il corpo del let-in

kind decl type.
kind nome_decl type.
type let_in list decl -> term -> term.
type coppia_decl nome_decl -> term -> decl.
%				 nome -> corpo ->.

% es:   let_in [coppia_decl x (num 1), coppia_decl y (num 2), coppia_decl z (num 3)] (x + y + z)
%              cioè   [x = 1, y = 2, z = 3] (x + y + z)
%              cioè   lam x \ lam y \ lam z \ x + y + z

% es:   let_in [coppia_decl id (lam A \ A)] (id 4)
%              cioè   [id = (lam A \ A)] (id 4)

% Deve considerare anche la lista L nel tipaggio
of (let_in L EXPR) T :- of EXPR T, check_list_let L.

type check_list_let list decl -> prop.
check_list_let [coppia_decl N C | TL] :- associa_tipo N T, of C T, check_list_let TL.

type associa_tipo nome_decl -> tipo -> prop.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% primo esempio senza polimorfismo: riuscire a tipare
% of 1 int.
% of 2 int.
% typeclass printable T [print, arr T int].
% istanza printable int [print, lam x \ x].
% istanza printable (list T) [print, lam l \ concat (map Print_elem l) ]
%  :- istanza printable T [print, Print_elem].
% of (app Fun Arg) Ty :-			% Ty = "tipo"
%   istanza N L,					% N = "nome", L = "lista"
%   cerca_in_L L Fun Te T,			% Te = "termine"
%   typeclass N TY Defs,
%   cerca_Fun_in_LTY Fun Defs Ty.
%% esempio:  of (app print 3) Z
%% deve istanziare Z con int.
% check_istanze :-		% Controlla che per ogni istanza del programma ci sia la corrispondente typeclass
%   istanza N ARG DEF,											% N = "nome", ARG = "argomento", DEF = lista di definizioni
%   (typeclass N ARG DECL, simil_of_list DEF DECL ; exit 0)		% DECL = lista di dichiarazioni
%   fail.
% check_istanze.	% Caso base
% test Prog L :-
%   simil_of_list per fare of su tutte le funzioni di L
% test [f, lam x \ print (app (app plus 1) 2)].
% test [f, lam x \ print [1,2,3]].


% Usando la mia sintassi:

type string tipo.
type int tipo.
type list tipo -> tipo.

type num int -> term.

of (num _N) int.

type print_int nome_fun.
type map nome_fun.
type concat nome_fun.

assume (fun_decl print_int (base (arr int string))).
assume (fun_decl map (for_all s \ for_all t \ base (arr (arr s t) (arr (list s) (list t))))).
assume (fun_decl concat (base (arr (list string) string))).

%% Test sui for_all
type test int -> tipo -> prop.
test 1 OUT :-
 of (lam l \ app (fun concat) (app (app (fun map) (fun print_int)) l)) OUT.

type printable nome_classe.
type print_ nome_fun.

typeclass printable T [fun_decl print_ (base (arr T string))].

istanza printable int [fun_impl print_ (fun print_int)].
istanza printable (list T) [fun_impl print_ (lam l \ app (fun concat) (app (app (fun map) Print_elem) l))]
 :- istanza printable T [fun_impl print_ Print_elem].

%test [f, lam x \ app (fun print_) (app (app plus 1) 2)].
%test [f, lam x \ app (fun print_) [1,2,3]].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% (22/11/2019)
%%%% TODO NEXT A
%
% implementare il caso of (fun F) che cerchi un'istanza di F in una type-class
%    1) cerchi la type-class che dichiara la funzione F
%    2) cerchi l'istanza che ti serve creando un constraint se il tipo
%       è una variabile
%% esempio1:  of (app (fun print_) (num 3))) Z
%%            output: Z = string
%% esempio2:  of (lam x \ app (fun print_) x)) Z
%%            output: Z = X -> string
%%            con un constraint  (istanza printable X L)


%%% Test
test 2 Z :- of (app (fun print_) (num 3)) Z.
test 3 Z :- of (lam x \ app (fun print_) x) Z.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% (22/11/2019)
%%%% TODO ORTHOGONAL (= ortgonale a TODO NEXT A)
%%  data una istanza, verificare se è ben definita rispetto alla sua typeclass
%%  esempio:  check (istanza printable int [fun_impl print_ (fun print_int)])
%%  esempio hard (ne riparliamo): come controllare una istanza condizionale come questa
%%    istanza printable (list T) [fun_impl print_ (lam l \ app (fun concat) (app (app (fun map) Print_elem) l))]
%%    :- istanza printable T [fun_impl print_ Print_elem].


type check_istanza prop -> prop.
check_istanza (istanza N TA_ LA) :- typeclass N TB_ LB, match_lista_fun LA LB.

% Controlla che ci siano funzioni con lo stesso nome e che abbiano lo stesso tipo
type match_lista_fun list implementation -> list declaration -> prop.
match_lista_fun [H|T] L :-
 search_fun H L LminusH,
 match_lista_fun T LminusH.

type search_fun implementation -> list declaration -> list declaration -> prop.
search_fun (fun_impl N1 C) [fun_decl N2 S | TL] [fun_decl N2 S | OUT] :- search_fun (fun_impl N1 C) TL OUT.		% ~ In questo modo la lista di output LminusH viene man mano riempita funzione dopo funzione?
search_fun (fun_impl N C) [fun_decl N S | TL] TL :- of C T, instantiate S T.		% Caso base
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% (22/11/2019)
%%%% TODO NEXT B
%% estendere la sintassi degli schemi con le istanze di type class
%%    ora:   for_all t \ base (t -> string)
%%    dopo:   for_all t \ implies (is_instance printable t) (base (t -> string))
%%
%% estendere il predicato instantiate in modo che cerchi le istanze


kind holds type.
type is_instance nome_classe -> tipo -> holds.

type implies holds -> schema -> schema.

% es1:   for_all t \ implies (is_instance printable t) (base (arr t string))
% es2:   for_all t1 \ implies (is_instance printable t1) (for_all t2 \ implies (is_instance printable t2) (for_all t3 \ (base (arr t1 (arr t2 t3)))))


instantiate (implies (is_instance N T) S) O :- istanza N T _L, instantiate S O.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% (22/11/2019)
%%%% TODO NEXT 3
%% implementare il let-in / implementare controllo di corrispondeza
%% fra fun_decl e fun_impl
%% recuperando i vincoli



% (31/10/2019)
% TODO 2: aggiunta delle type classes
%  - meccanismo per dichiarare le type classes
%    (meccanismo = predicato ELPI)
%    typeclass (printable T) [print, arr T string]
%  - meccanismo per dichiarare istanze di type classes
%    (meccanismo = predicato ELPI)
%      istanza (printable int) [print, lam x \ ...]
%      istanza (printable (list T)) [print, lam l \ concat (map Print_elem l) ]
%       :- istanza (printable T) [print, Print_elem].
%  - quando of trova un metodo di una type class
%    deve cercare un'istanza
%  - la funzione di ricerca di un'istanza deve generare
%    un constraint se il tipo e' una variabile
%  - cambiare di nuovo la sintassi dei tipi per permettere
%    di assumere type-class su variabili di tipo
%    es. forall T \ printable T => list T -> string
%    le => devono stare fra i forall e il tipo semplice
%  - cambiare la regola of per le definizioni di funzione
%    in modo che dopo aver tipato il corpo recuperi dall'insieme
%    dei vincoli tutte le type-class richieste e le trasformi
%    nelle premesse =>   (ELPI only)

% (31/10/2019)
% TODO 3: estensioni delle type classes
%  - implementare le estensioni sotto forma di regole
%    ELPI per il predicato di istanze
