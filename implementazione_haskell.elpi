kind typ type.
kind term type.

type app  term -> term -> term.
type lam  (term -> term) -> term.

type arr typ -> typ -> typ.

type of term -> typ -> prop.

mode (of i o).
of (uvar _ as X) T :- !, declare_constraint (of X T) [X].
of (app X Y) B :- of X (arr A B), of Y A.
of (lam F) (arr A B) :- pi x \ of x A => of (F x) B.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% primo esempio senza polimorfismo: riuscire a tipare
% of 1 int.
% of 2 int.
% typeclass printable T [print, arr T int].
% istanza printable int [print, lam x \ x].
% istanza printable (list T) [print, lam l \ concat (map Print_elem l) ]
%  :- istanza printable T [print, Print_elem].
% of (app Fun Arg) Ty :-
   istanza N L,
   cerca_in_L L Fun Te T,
   typeclass N TY Defs,
   cerca_Fun_in_LTY Fun Defs Ty.
%% esempio:  of (app print 3) Z
%% deve istanziare Z con int.
% check_istanze :-
   istanza N ARG DEF,
   (typeclass N ARG DECL, simil_of_list DEF DECL ; exit 0)
   fail.
% check_istanze.
% test Prog L :-
%   simil_of_list per fare of su tutte le funzioni di L
% test [f, lam x \ print (app (app plus 1) 2)].
% test [f, lam x \ print [1,2,3]].



%%%



% idea 1
%of X int :- Integer(X).

% idea 2
% e.g. (of1 7)
%type of1 int -> prop.

% idea 3
% e.g. (of2 7 int)
%type of2 int -> type -> prop.

% idea 4
%constraint of {
%   rule (of X int) <=> (1 is X); (2 is X); (3 is X); ... .
%}



%%%



% Tutti gli elementi della lista hanno quel tipo
type of_list list term -> typ -> prop.
of_list [H|T] X :- of H X, of_list T X.
of_list [] X.		% Caso base


% Ogni funzione della lista1 ha lo stesso nome e lo stesso tipo di una funzione contenuta nella lista2
type match_fun list term -> list term -> prop.
match_fun_list [] [].
match_fun_list [H|T] L :-
 search H L LminusH,
 match_fun_list T LminusH.

match_fun_list [H1|T1] [H2|T2] :- match_fun H1 H2, match_fun_list T1 T2.					% Confronta la prima coppia e (se fa match) prosegue ...
match_fun_list [H1|T1] [H2|T2] :-
match_fun_list [H1|T1] T2, match_fun_list T1 [H2|T2].		% ... altrimenti scorre la lista2 alla ricerca della funzione che faccia match (e T2 la controlla ripartendo dall'inizio della lista2)

type match_fun term -> term -> prop.
match_fun (fun_def S1 F) (fun_dic S1 T) :- of F T.


kind classes type.

type typeclass classes -> list term -> prop.

type classe string -> typ -> classes.

typeclass (classe S T) L :- of_list L (typ_arr (arr T _)).
% e.g. typeclass (classe "printable" T) [fun_dic "print" (typ_arr (arr T int)]


type istanza classes -> list term -> prop.

istanza (classe S T) L1 :- typeclass (classe S TA) L2, of_list L2 (arr TA TB), of_list L1 (arr T TB), match_fun L2 L1.		% ~ Va esteso al caso generale: un tipo generico e non soltanto (arr _ _)



test1 :-
 typeclass (classe "printable" T) [fun_dic "print" (arr T int)],
 istanza (classe "printable" int) [fun_def "print" (lam x \ x)].

% Dovrebbe generare errore
test1_err :-
 typeclass (classe "printable" T) [fun_dic "print" (arr T int)],
 istanza (classe "printable" int) [fun_def "abcde" (lam x \ x)].



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% TODO 1: haskell senza type classes
%  - implementare tutti i costrutti Haskell
%    usabili per definire funzioni
%    es. pattern matching (case), e let-in
%  - definire un programma Haskell come una lista
%    di funzioni ovvero coppie nome-corpo
%  - aggiungere il forall ai tipi
%    es:  forall T \ list T -> list T -> list T
%    ovvero: un tipo e' dato da una lista di
%    forall (imbricati) terminati da un tipo
%    fatto da sole arr
%    es. forall K \ forall V \ arr (K (arr (hash K V) V))
%    controesempio:  arr T (forall K \ K)
%  - implementare il predicato of per i nuovi costrutti
%  - la regola of per le funzioni deve inserire i
%    forall per ogni meta-variabile rimasta tale nel
%    corpo (ELPI only)



type step term -> term -> prop.

step (app (lam F) X) (F X).



%%% Funzione definita con il costrutto case

let f x =
 match x of
    O => O
  | S y => y + 2

case x [branch "0" 0, branch "S" (lam y \ y + 2)])
type case term -> list pair -> term.
kind pair type.
type branch string -> term -> pair.

type fun_case list term -> term.
%			  (coppie input-return) -> input -> funzione definita con case

type coppia_case term -> term -> term.
%				 input -> return -> termine coppia_case


of (coppia_case A B) (typ_arr (arr TA TB)) :- of A TA, of B TB.		% ~ E' corretto attribuire a coppia_case il tipo 'arr'? O sarebbe meglio introdurre un nuovo tipo (es: 'coppia')?

of (fun_case L) (typ_arr (arr TA TB)) :- of_list L (typ_arr (arr TA TB)).
% Caso base:
%  of (fun_case (coppia_case A B)) (arr TA TB) :- of A TA, of B TB.
% Caso generale:
%  of (fun_case (coppia_case A1 B1) (coppia_case A2 B2) (coppia_case A3 B3) [...]) (arr TA TB)
%   :- of A1 TA, of A2 TA, of A3 TA, [...], of B1 TB, of B2 TB, of B3 TB, [...].


%B :- app (fun_case (coppia_case A B)) A.
step (app (fun_case (coppia_case A B)) A) B.


mode (of i o).
of (uvar _ as X) (typ_arr (arr T1 T2)) :- !, declare_constraint (of X (typ_for (forall T1 (forall T2 _)) (arr T1 T2))) [X].		% ~ Va esteso al caso generale



%%% Funzione definita con il costrutto let-in


type fun_let list term -> term.
%			 (triple input-let-in) -> funzione definita con let

type tripla_let term -> term -> term -> term.
%				input -> corpo_let -> corpo_in -> termine tripla_let


of (tripla_let I (lam F) (lam G))) (arr TI (arr TF TG)) :- of I TI, of (lam F) (arr TI TF), of (lam G) (arr TF TG).

of (fun_let L) (arr TI TG) :- of_list L (arr TI (arr TF TG)).
% Caso base:
%  of (fun_let (tripla_let I (lam F) (lam G))) (arr TI TG) :- of I TI, of (lam F) (arr TI TF), of (lam G) (arr TF TG).		% ~ Va esteso al caso generale con una lista di triple
% Caso generale:
%  of (fun_let (tripla_let I1 (lam F1) (lam G1)) (tripla_let I2 (lam F2) (lam G2)) (tripla_let I3 (lam F3) (lam G3)) [...]) (arr TI TG)
%   :- of I1 TI, of I2 TI, of I3 TI, [...], of (lam F1) (arr TI TF), of (lam F2) (arr TI TF), of (lam F3) (arr TI TF), [...], of (lam G1) (arr TF TG), of (lam G2) (arr TF TG), of (lam G3) (arr TF TG), [...].


%app (lam G) (app (lam F) I) :- app (fun_let (tripla_let I (lam F) (lam G))) I.
step (app (fun_let (tripla_let I (lam F) (lam G))) I) (app (lam G) (app (lam F) I)).
% app (lam G) (app (lam F) I) ...corrisponde a... G (F I)



%%% Funzioni come coppie nome-corpo

% ~ Come corpo dovrebbe prendere 'fun_case' e 'fun_let' (invece di 'lam F')?


type fun_def string -> term -> term.
%		 nome funzione -> corpo funzione -> termine fun

of (fun_def S (lam F)) (arr T1 T2) :- of (lam F) (arr T1 T2).

%lam F :- fun_def S (lam F).
step (fun_def S (lam F)) (lam F).
step (app (fun_def S (lam F)) X) (app (lam F) X).


type fun_dic string -> typ -> term.
%			 nome funzione -> tipo funzione -> termine.

of (fun_dic S (arr T1 T2)) (arr T1 T2).



%%% Programma Haskell come lista di funzioni

% ~ Con 'programma Haskell' si intende questo seguente? O il file .elpi in generale?

type prog list term -> term.		% ~ E' giusto che prog restituisca un term?
%		  lista di funzioni -> ?

% Tutte le funzioni del programma sono di tipo 'arr T1 T2'
of (prog L) (arr T1 T2) :- of_list L (arr T1 T2).

%app (prog [H|T]) I :- app H I.
%app (prog [H|T]) I :- app (prog T) I.
%app (prog [H|[]]) I :- app H I.		% Caso base



%%% Forall aggiunto ai tipi

% ~ Si possono avere due tipi (quello fatto di forall+arr e quello fatto di sole arr) oppure soltanto uno fatto di forall+arr?


% idea 1 (forall e arr separati)

kind schema type.
kind tipo type.

type arr tipo -> tipo -> tipo.

type for_all (tipo -> schema) -> schema.
type base tipo -> schema.

es.:   for_all X \ for_all Y \ base (arr X Y).

kind declaration type.
type fun_decl string -> schema -> declaration.
type of term -> tipo -> o.

es.
 Term =
  let id = lam A \ A in     il termine A \ A ha tipo X -> X
                            id viene dichiarato con schema for_all X \ X -> X
   id 4                     ha tipo int
 tutto Term ha tipo int




kind typ_single type.

type arr tipo -> tipo -> tipo.

type forall typ_single -> schema -> schema.		% ~ Come si fa a scrivere l'ultimo 'forall'? Con 'nil'?

type typ_for schema -> tipo -> typ.		% e.g. typ_for (forall T1 (forall T2 (forall T3 _))) (arr T1 (arr T2 T3))
type typ_arr tipo -> typ.				% e.g. typ_arr (arr T1 (arr T2 T3))
type typ_sing type -> typ.				% e.g. typ_sing T1


% idea 2 (forall e arr imbricati)
% PROBLEMA: 'arr' potrebbe prendere al suo interno dei 'forall'

% e.g. forall T1 (forall T2 (forall T3 (arr T1 (arr T2 T3))))

%kind scheme type.

%type forall scheme -> typ -> typ.






























%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% TODO 2: aggiunta delle type classes
%  - meccanismo per dichiarare le type classes
%    (meccanismo = predicato ELPI)
%    typeclass (printable T) [print, arr T string]
%  - meccanismo per dichiarare istanze di type classes
%    (meccanismo = predicato ELPI)
%      istanza (printable int) [print, lam x \ ...]
%      istanza (printable (list T)) [print, lam l \ concat (map Print_elem l) ]
%       :- istanza (printable T) [print, Print_elem].
%  - quando of trova un metodo di una type class
%    deve cercare un'istanza
%  - la funzione di ricerca di un'istanza deve generare
%    un constraint se il tipo e' una variabile
%  - cambiare di nuovo la sintassi dei tipi per permettere
%    di assumere type-class su variabili di tipo
%    es. forall T \ printable T => list T -> string
%    le => devono stare fra i forall e il tipo semplice
%  - cambiare la regola of per le definizioni di funzione
%    in modo che dopo aver tipato il corpo recuperi dall'insieme
%    dei vincoli tutte le type-class richieste e le trasformi
%    nelle premesse =>   (ELPI only)

% TODO 3: estensioni delle type classes
%  - implementare le estensioni sotto forma di regole
%    ELPI per il predicato di istanze
