kind tipo type.
kind term type.

type app  term -> term -> term.
type lam  (term -> term) -> term.

type arr tipo -> tipo -> tipo.

type of term -> tipo -> prop.

mode (of i o).
of (uvar _ as X) T :- !, declare_constraint (of X T) [X].
of (app X Y) B :- of X (arr A B), of Y A.
of (lam F) (arr A B) :- pi x \ of x A => of (F x) B.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





% primo esempio senza polimorfismo: riuscire a tipare
% of 1 int.
% of 2 int.
% typeclass printable T [print, arr T int].
% istanza printable int [print, lam x \ x].
% istanza printable (list T) [print, lam l \ concat (map Print_elem l) ]
%  :- istanza printable T [print, Print_elem].
% of (app Fun Arg) Ty :-			% Ty = "tipo"
%   istanza N L,					% N = "nome", L = "lista"
%   cerca_in_L L Fun Te T,			% Te = "termine"
%   typeclass N TY Defs,
%   cerca_Fun_in_LTY Fun Defs Ty.
%% esempio:  of (app print 3) Z
%% deve istanziare Z con int.
% check_istanze :-		% Controlla che per ogni istanza del programma ci sia la corrispondente typeclass
%   istanza N ARG DEF,											% N = "nome", ARG = "argomento", DEF = lista di definizioni
%   (typeclass N ARG DECL, simil_of_list DEF DECL ; exit 0)		% DECL = lista di dichiarazioni
%   fail.
% check_istanze.	% Caso base
% test Prog L :-
%   simil_of_list per fare of su tutte le funzioni di L
% test [f, lam x \ print (app (app plus 1) 2)].
% test [f, lam x \ print [1,2,3]].



% Usando la mia sintassi:

of 1 int.
of 2 int.

typeclass printable T [fun_decl print_ (for_all T \ base (arr T int))].

istanza printable int [fun_impl print_ (lam x \ x)].
istanza printable (list T) [fun_impl print_ (lam l \ app concat (app map Print_elem l))]
 :- istanza printable T [fun_impl print_ Print_elem].

test [f, lam x \ app (fun print_) (app (app plus 1) 2)].
test [f, lam x \ app (fun print_) [1,2,3]].





%%%





kind nome_classe type.


type typeclass nome_classe -> tipo -> list declaration -> prop.		% ~ E' giusto che sia una 'prop'?

typeclass N T L.


type istanza nome_classe -> tipo -> list implementation -> prop.	% ~ E' giusto che sia una 'prop'?

istanza N T L.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





% TODO 1: haskell senza type classes
%  - implementare tutti i costrutti Haskell
%    usabili per definire funzioni
%    es. pattern matching (case), e let-in
%  - definire un programma Haskell come una lista
%    di funzioni ovvero coppie nome-corpo
%  - aggiungere il forall ai tipi
%    es:  forall T \ list T -> list T -> list T
%    ovvero: un tipo e' dato da una lista di
%    forall (imbricati) terminati da un tipo
%    fatto da sole arr
%    es. forall K \ forall V \ arr (K (arr (hash K V) V))
%    controesempio:  arr T (forall K \ K)
%  - implementare il predicato of per i nuovi costrutti
%  - la regola of per le funzioni deve inserire i
%    forall per ogni meta-variabile rimasta tale nel
%    corpo (ELPI only)





%%% Funzione definita con il costrutto case

% Esempio in pseudocodice:
%
%  let f x =
%   match x of
%      O => O
%    | S y => y + 2


kind pair type.

type case_of term -> list pair -> term.

type branch string -> term -> pair.

% es:   case_of x [branch "0" 0, branch "S" (lam y \ y + 2)]


of (case_of X L) T :- check_output_list L T.


type check_output_list list pair -> tipo -> prop.

check_output_list [branch S R | T] X :- of R X, check_output_list T X.
check_output_list [] X.	% Caso base





%%% Funzione definita con il costrutto let-in

% es:
%       let
%           id = lam A \ A
%       in
%           id 4


kind decl type.
kind nome type.


type let_in list decl -> term -> term.

type coppia_decl nome -> term -> decl.

% es:   let_in [coppia_decl x 1, coppia_decl y 2, coppia_decl z 3] (x + y + z)
%              [x = 1, y = 2, z = 3] (x + y + z)
%              lam x \ lam y \ lam z \ x + y + z

% es:   let_in [coppia_decl id (lam A \ A)] (id 4)
%              [id = (lam A \ A)] (id 4)


of (let_in L EXPR) T :- of EXPR T.





%%% Funzioni come coppie nome-corpo

% Tre casi d'uso:
%
%   - Dichiarazione      es: fun_decl print (for_all T \ base (arr T int))
%   - Implementazione    es: fun_impl print (lam x \ x)
%   - Uso                es: print 4


kind nome_fun type.


kind declaration type.

type fun_decl nome_fun -> schema -> declaration.		% ~ Non dovrebbe essere 'prop'?
%             nome funzione -> tipo funzione -> _ .

% es:   fun_decl foo (for_all T \ base (arr T T))

% es.
%  Term =
%   let id = lam A \ A in     % il termine A \ A ha tipo X -> X
%                             % id viene dichiarato con schema for_all X \ X -> X
%    id 4                     % ha tipo int
%  tutto Term ha tipo int


kind implementation type.

type fun_impl nome_fun -> term -> implementation.		% ~ Non dovrebbe essere 'prop'?
%             nome funzione -> corpo funzione -> _ .

% es:   fun_impl foo1 (lam x \ lam y \ x + y)
%       fun_impl foo2 (case_of x [branch "0" 0, branch "S" (lam y \ y + 2)])
%       fun_impl foo3 (let_in [coppia_decl id (lam A \ A)] (id 4))


type fun nome_fun -> term.

%of (fun N) T :- fun_impl N C, of C T.		% ~ Non va bene se fun_impl non Ã¨ 'prop'

% es:   app (fun print) 4
%       =
%       print 4





%%% Forall aggiunto ai tipi

% Si possono avere due tipi (quello fatto di forall+arr e quello fatto di sole arr)
%
%   es_forall+arr:      for_all T1 \ for_all T2 \ base (arr T1 T2)
%   es_arr:             arr T1 T2


kind schema type.

type for_all (tipo -> schema) -> schema.
type base tipo -> schema.

% es.:   for_all X \ for_all Y \ base (arr X Y).









































%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% TODO 2: aggiunta delle type classes
%  - meccanismo per dichiarare le type classes
%    (meccanismo = predicato ELPI)
%    typeclass (printable T) [print, arr T string]
%  - meccanismo per dichiarare istanze di type classes
%    (meccanismo = predicato ELPI)
%      istanza (printable int) [print, lam x \ ...]
%      istanza (printable (list T)) [print, lam l \ concat (map Print_elem l) ]
%       :- istanza (printable T) [print, Print_elem].
%  - quando of trova un metodo di una type class
%    deve cercare un'istanza
%  - la funzione di ricerca di un'istanza deve generare
%    un constraint se il tipo e' una variabile
%  - cambiare di nuovo la sintassi dei tipi per permettere
%    di assumere type-class su variabili di tipo
%    es. forall T \ printable T => list T -> string
%    le => devono stare fra i forall e il tipo semplice
%  - cambiare la regola of per le definizioni di funzione
%    in modo che dopo aver tipato il corpo recuperi dall'insieme
%    dei vincoli tutte le type-class richieste e le trasformi
%    nelle premesse =>   (ELPI only)

% TODO 3: estensioni delle type classes
%  - implementare le estensioni sotto forma di regole
%    ELPI per il predicato di istanze
